// Integration Test Template: api/tests/integration/expenses.test.ts
// This template validates full endpoint flows using HTTP

import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import request from 'supertest';
import app from '../../src/server';

describe('Expense Endpoints - Integration Tests', () => {
  let server: any;
  const baseUrl = 'http://localhost:3000';

  beforeAll(async () => {
    // Server start setup
  });

  afterAll(async () => {
    // Server cleanup
  });

  describe('POST /expenses - Success Cases', () => {
    it('should create expense and return 201 with ID', async () => {
      const response = await request(app)
        .post('/expenses')
        .send({
          amount: 25.50,
          category: 'food',
          date: '2025-11-05'
        });

      expect(response.status).toBe(201);
      expect(response.body).toHaveProperty('id');
      expect(response.body).toHaveProperty('amount', 25.50);
      expect(response.body).toHaveProperty('category', 'food');
      expect(response.body).toHaveProperty('date', '2025-11-05');
      expect(response.body.id).toMatch(/^[0-9a-f-]{36}$/i); // UUID format
    });

    it('should create multiple expenses with unique IDs', async () => {
      const expense1 = await request(app)
        .post('/expenses')
        .send({ amount: 10.00, category: 'food', date: '2025-11-01' });

      const expense2 = await request(app)
        .post('/expenses')
        .send({ amount: 20.00, category: 'transport', date: '2025-11-02' });

      expect(expense1.status).toBe(201);
      expect(expense2.status).toBe(201);
      expect(expense1.body.id).not.toBe(expense2.body.id);
    });

    it('should persist expenses (available in summary)', async () => {
      const createRes = await request(app)
        .post('/expenses')
        .send({ amount: 50.00, category: 'utilities', date: '2025-11-05' });

      const summaryRes = await request(app).get('/expenses/summary');

      expect(createRes.status).toBe(201);
      expect(summaryRes.status).toBe(200);
      expect(summaryRes.body.total).toBeGreaterThanOrEqual(50.00);
    });
  });

  describe('POST /expenses - Validation Errors', () => {
    it('should reject negative amount with 400', async () => {
      const response = await request(app)
        .post('/expenses')
        .send({
          amount: -10,
          category: 'food',
          date: '2025-11-05'
        });

      expect(response.status).toBe(400);
      expect(response.body).toHaveProperty('errors');
      expect(response.body.errors[0]).toHaveProperty('field', 'amount');
      expect(response.body.errors[0].message).toContain('greater than 0');
    });

    it('should reject zero amount with 400', async () => {
      const response = await request(app)
        .post('/expenses')
        .send({
          amount: 0,
          category: 'food',
          date: '2025-11-05'
        });

      expect(response.status).toBe(400);
      expect(response.body.errors[0].field).toBe('amount');
    });

    it('should reject invalid date format with 400 and show expected format', async () => {
      const response = await request(app)
        .post('/expenses')
        .send({
          amount: 25.50,
          category: 'food',
          date: '11/05/2025'
        });

      expect(response.status).toBe(400);
      expect(response.body.errors[0].field).toBe('date');
      expect(response.body.errors[0].message).toContain('YYYY-MM-DD');
      expect(response.body.errors[0].message).toContain('received:');
      expect(response.body.errors[0].message).toContain('11/05/2025');
    });

    it('should reject missing amount field', async () => {
      const response = await request(app)
        .post('/expenses')
        .send({
          category: 'food',
          date: '2025-11-05'
        });

      expect(response.status).toBe(400);
      expect(response.body.errors[0].field).toBe('amount');
    });

    it('should reject missing category field', async () => {
      const response = await request(app)
        .post('/expenses')
        .send({
          amount: 25.50,
          date: '2025-11-05'
        });

      expect(response.status).toBe(400);
      expect(response.body.errors[0].field).toBe('category');
    });

    it('should reject missing date field', async () => {
      const response = await request(app)
        .post('/expenses')
        .send({
          amount: 25.50,
          category: 'food'
        });

      expect(response.status).toBe(400);
      expect(response.body.errors[0].field).toBe('date');
    });

    it('should reject empty category string', async () => {
      const response = await request(app)
        .post('/expenses')
        .send({
          amount: 25.50,
          category: '',
          date: '2025-11-05'
        });

      expect(response.status).toBe(400);
      expect(response.body.errors[0].field).toBe('category');
    });
  });

  describe('GET /expenses/summary - No Filters', () => {
    it('should return 200 with aggregated totals', async () => {
      const response = await request(app).get('/expenses/summary');

      expect(response.status).toBe(200);
      expect(response.body).toHaveProperty('total');
      expect(response.body).toHaveProperty('count');
      expect(response.body).toHaveProperty('filters');
      expect(typeof response.body.total).toBe('number');
      expect(typeof response.body.count).toBe('number');
    });

    it('should aggregate multiple expenses correctly', async () => {
      // Create known expenses
      await request(app)
        .post('/expenses')
        .send({ amount: 10.00, category: 'food', date: '2025-11-01' });

      await request(app)
        .post('/expenses')
        .send({ amount: 20.00, category: 'transport', date: '2025-11-02' });

      const summary = await request(app).get('/expenses/summary');

      expect(summary.body.total).toBeGreaterThanOrEqual(30.00);
      expect(summary.body.count).toBeGreaterThanOrEqual(2);
    });

    it('should return empty filters object when no filters applied', async () => {
      const response = await request(app).get('/expenses/summary');

      expect(response.body.filters).toEqual({});
    });
  });

  describe('GET /expenses/summary - Category Filter', () => {
    it('should filter by category and return 200', async () => {
      const response = await request(app)
        .get('/expenses/summary')
        .query({ category: 'food' });

      expect(response.status).toBe(200);
      expect(response.body.filters).toHaveProperty('category', 'food');
    });

    it('should aggregate only matching category', async () => {
      // Create known expenses
      const food = await request(app)
        .post('/expenses')
        .send({ amount: 15.00, category: 'food', date: '2025-11-05' });

      const transport = await request(app)
        .post('/expenses')
        .send({ amount: 30.00, category: 'transport', date: '2025-11-05' });

      const summary = await request(app)
        .get('/expenses/summary')
        .query({ category: 'food' });

      expect(summary.body.total).toBeGreaterThanOrEqual(15.00);
      // Should not include transport expenses
    });

    it('should return 0 for non-existent category', async () => {
      const response = await request(app)
        .get('/expenses/summary')
        .query({ category: 'nonexistent' });

      expect(response.status).toBe(200);
      expect(response.body.total).toBe(0);
      expect(response.body.count).toBe(0);
      expect(response.body.filters.category).toBe('nonexistent');
    });
  });

  describe('GET /expenses/summary - Month Filter', () => {
    it('should filter by month (YYYY-MM format) and return 200', async () => {
      const response = await request(app)
        .get('/expenses/summary')
        .query({ month: '2025-11' });

      expect(response.status).toBe(200);
      expect(response.body.filters).toHaveProperty('month', '2025-11');
    });

    it('should aggregate only matching month', async () => {
      // Create known expenses in different months
      const nov = await request(app)
        .post('/expenses')
        .send({ amount: 40.00, category: 'food', date: '2025-11-15' });

      const oct = await request(app)
        .post('/expenses')
        .send({ amount: 50.00, category: 'food', date: '2025-10-15' });

      const summary = await request(app)
        .get('/expenses/summary')
        .query({ month: '2025-11' });

      expect(summary.body.total).toBeGreaterThanOrEqual(40.00);
      // Should not include October expenses
    });

    it('should return 0 for non-existent month', async () => {
      const response = await request(app)
        .get('/expenses/summary')
        .query({ month: '2024-01' });

      expect(response.status).toBe(200);
      expect(response.body.total).toBe(0);
      expect(response.body.count).toBe(0);
      expect(response.body.filters.month).toBe('2024-01');
    });
  });

  describe('GET /expenses/summary - Combined Filters', () => {
    it('should apply both category and month filters (AND logic)', async () => {
      const response = await request(app)
        .get('/expenses/summary')
        .query({ category: 'food', month: '2025-11' });

      expect(response.status).toBe(200);
      expect(response.body.filters).toHaveProperty('category', 'food');
      expect(response.body.filters).toHaveProperty('month', '2025-11');
    });

    it('should aggregate only expenses matching both criteria', async () => {
      // Create test expenses
      const foodNov = await request(app)
        .post('/expenses')
        .send({ amount: 25.00, category: 'food', date: '2025-11-05' });

      const foodOct = await request(app)
        .post('/expenses')
        .send({ amount: 30.00, category: 'food', date: '2025-10-05' });

      const transportNov = await request(app)
        .post('/expenses')
        .send({ amount: 35.00, category: 'transport', date: '2025-11-05' });

      const summary = await request(app)
        .get('/expenses/summary')
        .query({ category: 'food', month: '2025-11' });

      expect(summary.body.total).toBeGreaterThanOrEqual(25.00);
      // Should not include Oct food or Nov transport
    });

    it('should return 0 when no expenses match both filters', async () => {
      const response = await request(app)
        .get('/expenses/summary')
        .query({ category: 'food', month: '2024-01' });

      expect(response.status).toBe(200);
      expect(response.body.total).toBe(0);
      expect(response.body.count).toBe(0);
    });
  });

  describe('Error Handling', () => {
    it('should return 400 for invalid JSON', async () => {
      const response = await request(app)
        .post('/expenses')
        .set('Content-Type', 'application/json')
        .send('invalid json');

      expect(response.status).toBe(400);
    });

    it('should handle missing Content-Type gracefully', async () => {
      const response = await request(app)
        .post('/expenses')
        .send('{ "amount": 25.50 }');

      // Should still parse or return appropriate error
      expect([400, 200]).toContain(response.status);
    });
  });
});

